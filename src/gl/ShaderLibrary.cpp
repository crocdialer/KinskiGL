/* Generated file, do not edit! */

#include "ShaderLibrary.h"


char const* const gouraud_vert = 
   "#version 410\n"
   "struct Material\n"
   "{ \n"
   "   vec4 diffuse;\n"
   "   vec4 ambient; \n"
   "   vec4 specular; \n"
   "   vec4 emission;\n"
   "   float shinyness;\n"
   "};\n"
   "uniform int u_numLights;\n"
   "struct Lightsource \n"
   "{\n"
   "  int type;\n"
   "  vec3 position;\n"
   "  vec4 diffuse; \n"
   "  vec4 ambient; \n"
   "  vec4 specular; \n"
   "  float constantAttenuation; \n"
   "  float linearAttenuation; \n"
   "  float quadraticAttenuation; \n"
   "  vec3 spotDirection; \n"
   "  float spotCosCutoff; \n"
   "  float spotExponent; \n"
   "};\n"
   "vec4 shade(in Lightsource light, in Material mat, in vec3 normal, in vec3 eyeVec, in vec4 base_color) \n"
   "{\n"
   "  vec3 lightDir = light.type > 0 ? (light.position - eyeVec) : -light.position;\n"
   "  vec3 L = normalize(lightDir); \n"
   "  vec3 E = normalize(-eyeVec); \n"
   "  vec3 R = reflect(-L, normal); \n"
   "  vec4 ambient = mat.ambient * light.ambient; \n"
   "  float att = 1.0; \n"
   "  float nDotL = dot(normal, L); \n"
   "  \n"
   "  if (light.type > 0) \n"
   "  {\n"
   "    float dist = length(lightDir); \n"
   "    att = 1.0 / (light.constantAttenuation + light.linearAttenuation * dist + light.quadraticAttenuation * dist * dist); \n"
   "    if(light.type > 1) \n"
   "    {\n"
   "      float spotEffect = dot(normalize(light.spotDirection), -L); \n"
   "      if (spotEffect < light.spotCosCutoff) \n"
   "      {\n"
   "        att = 0.0;\n"
   "        base_color * ambient; \n"
   "      }\n"
   "      spotEffect = pow(spotEffect, light.spotExponent); \n"
   "      att *= spotEffect; \n"
   "    }\n"
   "  } \n"
   "  nDotL = max(0.0, nDotL); \n"
   "  float specIntesity = clamp(pow( max(dot(R, E), 0.0), mat.shinyness), 0.0, 1.0); \n"
   "  vec4 diffuse = att * mat.diffuse * light.diffuse * vec4(vec3(nDotL), 1.0); \n"
   "  vec4 spec = att * mat.specular * light.specular * specIntesity; spec.a = 0.0; \n"
   "  return base_color * (ambient + diffuse) + spec; \n"
   "}\n"
   "uniform mat4 u_modelViewMatrix; \n"
   "uniform mat4 u_modelViewProjectionMatrix; \n"
   "uniform mat3 u_normalMatrix; \n"
   "uniform mat4 u_textureMatrix; \n"
   "uniform Material u_material; \n"
   "uniform Lightsource u_lights[16]; \n"
   "layout(location = 0) in vec4 a_vertex; \n"
   "layout(location = 1) in vec3 a_normal; \n"
   "layout(location = 2) in vec4 a_texCoord; \n"
   "out VertexData \n"
   "{\n"
   "  vec4 color;\n"
   "  vec4 texCoord; \n"
   "} vertex_out;\n"
   "void main() \n"
   "{\n"
   "  vertex_out.texCoord = u_textureMatrix * a_texCoord;\n"
   "  vec3 normal = normalize(u_normalMatrix * a_normal); \n"
   "  vec3 eyeVec = (u_modelViewMatrix * a_vertex).xyz;\n"
   "  vec4 shade_color = vec4(0);\n"
   "  if(u_numLights > 0)\n"
   "    shade_color += shade(u_lights[0], u_material, normal, eyeVec, vec4(1)); \n"
   "  \n"
   "  if(u_numLights > 1)\n"
   "    shade_color += shade(u_lights[1], u_material, normal, eyeVec, vec4(1));\n"
   "  \n"
   "  vertex_out.color = shade_color; \n"
   "  gl_Position = u_modelViewProjectionMatrix * a_vertex; \n"
   "}\n"
;

char const* const phong_vert = 
   "#version 410\n"
   "uniform mat4 u_modelViewMatrix; \n"
   "uniform mat4 u_modelViewProjectionMatrix; \n"
   "uniform mat3 u_normalMatrix; \n"
   "uniform mat4 u_textureMatrix; \n"
   "layout(location = 0) in vec4 a_vertex; \n"
   "layout(location = 1) in vec3 a_normal; \n"
   "layout(location = 2) in vec4 a_texCoord; \n"
   "out VertexData\n"
   "{\n"
   "  vec4 color; \n"
   "  vec4 texCoord; \n"
   "  vec3 normal; \n"
   "  vec3 eyeVec; \n"
   "} vertex_out; \n"
   "void main()\n"
   "{\n"
   "  vertex_out.normal = normalize(u_normalMatrix * a_normal); \n"
   "  vertex_out.texCoord = u_textureMatrix * a_texCoord; \n"
   "  vertex_out.eyeVec = (u_modelViewMatrix * a_vertex).xyz; \n"
   "  gl_Position = u_modelViewProjectionMatrix * a_vertex; \n"
   "}\n"
;

char const* const phong_normalmap_vert = 
   "#version 330\n"
   "uniform mat4 u_modelViewMatrix; \n"
   "uniform mat4 u_modelViewProjectionMatrix; \n"
   "uniform mat3 u_normalMatrix; \n"
   "uniform mat4 u_textureMatrix; \n"
   "uniform vec3 u_lightDir; \n"
   "in vec4 a_vertex; \n"
   "in vec4 a_texCoord; \n"
   "in vec3 a_normal; \n"
   "in vec3 a_tangent; \n"
   "out VertexData\n"
   "{\n"
   "  vec4 color; \n"
   "  vec4 texCoord; \n"
   "  vec3 normal; \n"
   "  vec3 eyeVec; \n"
   "  vec3 lightDir; \n"
   "} vertex_out; \n"
   "void main()\n"
   "{\n"
   "  vertex_out.normal = normalize(u_normalMatrix * a_normal); \n"
   "  vec3 t = normalize (u_normalMatrix * a_tangent); \n"
   "  vec3 b = cross(vertex_out.normal, t); \n"
   "  mat3 tbnMatrix = mat3(t,b, vertex_out.normal); \n"
   "  vertex_out.eyeVec = tbnMatrix * normalize(- (u_modelViewMatrix * a_vertex).xyz); \n"
   "  vertex_out.lightDir = tbnMatrix * u_lightDir; \n"
   "  vertex_out.texCoord = u_textureMatrix * a_texCoord; \n"
   "  gl_Position = u_modelViewProjectionMatrix * a_vertex; \n"
   "}\n"
;

char const* const phong_skin_vert = 
   "#version 330\n"
   "uniform mat4 u_modelViewMatrix; \n"
   "uniform mat4 u_modelViewProjectionMatrix; \n"
   "uniform mat3 u_normalMatrix; \n"
   "uniform mat4 u_textureMatrix; \n"
   "uniform mat4 u_bones[110]; \n"
   "in vec4 a_vertex; \n"
   "in vec4 a_texCoord; \n"
   "in vec3 a_normal; \n"
   "in ivec4 a_boneIds; \n"
   "in vec4 a_boneWeights; \n"
   "out VertexData\n"
   "{\n"
   "  vec4 color; \n"
   "  vec4 texCoord; \n"
   "  vec3 normal;\n"
   "  vec3 eyeVec; \n"
   "} vertex_out; \n"
   "void main()\n"
   "{\n"
   "  vec4 newVertex = vec4(0); \n"
   "  vec4 newNormal = vec4(0); \n"
   "  \n"
   "  for (int i = 0; i < 4; i++)\n"
   "  {\n"
   "    newVertex += u_bones[a_boneIds[i]] * a_vertex * a_boneWeights[i]; \n"
   "    newNormal += u_bones[a_boneIds[i]] * vec4(a_normal, 0.0) * a_boneWeights[i]; \n"
   "  }\n"
   "  vertex_out.normal = normalize(u_normalMatrix * newNormal.xyz); \n"
   "  vertex_out.texCoord = u_textureMatrix * a_texCoord; \n"
   "  vertex_out.eyeVec = (u_modelViewMatrix * newVertex).xyz; \n"
   "  gl_Position = u_modelViewProjectionMatrix * vec4(newVertex.xyz, 1.0);\n"
   "}\n"
;

char const* const points_vert = 
   "#version 330\n"
   "uniform mat4 u_modelViewMatrix; \n"
   "uniform mat4 u_modelViewProjectionMatrix; \n"
   "uniform float u_pointSize; \n"
   "uniform struct\n"
   "{\n"
   "  float constant; \n"
   "  float linear; \n"
   "  float quadratic; \n"
   "} u_point_attenuation; \n"
   "layout(location = 0) in vec4 a_vertex; \n"
   "//layout(location = 1) in vec3 a_normal; \n"
   "//layout(location = 2) in vec4 a_texCoord;\n"
   "layout(location = 3) in vec4 a_color; \n"
   "layout(location = 4) in float a_pointSize; \n"
   "out vec4 v_color; \n"
   "out vec3 v_eyeVec; \n"
   "void main()\n"
   "{\n"
   "  v_color = a_color; \n"
   "  v_eyeVec = -(u_modelViewMatrix * a_vertex).xyz; \n"
   "  float d = length(v_eyeVec); \n"
   "  float attenuation = 1.0 / (u_point_attenuation.constant + u_point_attenuation.linear * d + u_point_attenuation.quadratic * (d * d)); \n"
   "  gl_PointSize = max(a_pointSize, u_pointSize) * attenuation; \n"
   "  gl_Position = u_modelViewProjectionMatrix * a_vertex; \n"
   "}\n"
;

char const* const unlit_vert = 
   "#version 410\n"
   "uniform mat4 u_modelViewProjectionMatrix;\n"
   "uniform mat4 u_textureMatrix;\n"
   "layout(location = 0) in vec4 a_vertex; \n"
   "layout(location = 2) in vec4 a_texCoord;\n"
   "layout(location = 3) in vec4 a_color; \n"
   "out VertexData\n"
   "{ \n"
   "  vec4 color;\n"
   "  vec2 texCoord;\n"
   "} vertex_out;\n"
   "void main() \n"
   "{\n"
   "  vertex_out.color = a_color;\n"
   "  vertex_out.texCoord = (u_textureMatrix * a_texCoord).xy;\n"
   "  gl_Position = u_modelViewProjectionMatrix * a_vertex; \n"
   "}\n"
;

char const* const unlit_rect_vert = 
   "#version 410\n"
   "uniform mat4 u_modelViewProjectionMatrix;\n"
   "uniform mat4 u_textureMatrix;\n"
   "uniform vec2 u_texture_size = vec2(1.0);\n"
   "in vec4 a_vertex;\n"
   "in vec4 a_color;\n"
   "in vec4 a_texCoord; \n"
   "out VertexData\n"
   "{ \n"
   "  vec4 color;\n"
   "  vec2 texCoord;\n"
   "} vertex_out;\n"
   "void main() \n"
   "{\n"
   "  vertex_out.color = a_color;\n"
   "  vertex_out.texCoord = (u_textureMatrix * a_texCoord).xy * u_texture_size;\n"
   "  gl_Position = u_modelViewProjectionMatrix * a_vertex; \n"
   "}\n"
;

char const* const lines_2D_geom = 
   "#version 330\n"
   "layout(lines) in;\n"
   "layout (triangle_strip, max_vertices = 4) out; \n"
   "uniform float u_line_thickness; \n"
   "uniform vec2 u_window_size; \n"
   "in VertexData\n"
   "{\n"
   "  vec4 color; \n"
   "  vec2 texCoord; \n"
   "} vertex_in[2]; \n"
   "out VertexData \n"
   "{ \n"
   "  vec4 color; \n"
   "  vec2 texCoord; \n"
   "} vertex_out; \n"
   "vec2 screen_space(vec4 vertex) \n"
   "{\n"
   "  return vertex.xy / vertex.w; \n"
   "} \n"
   "void main() \n"
   "{\n"
   "  vec2 p0 = screen_space(gl_in[0].gl_Position); \n"
   "  vec2 p1 = screen_space(gl_in[1].gl_Position); \n"
   "  vec2 v0 = normalize(p1 - p0); \n"
   "  vec2 n0 = vec2(-v0.y, v0.x); \n"
   "  vec2 bias = n0 * u_line_thickness / u_window_size; \n"
   "  vertex_out.color = vertex_in[0].color; \n"
   "  vertex_out.texCoord = vec2(0, 1); \n"
   "  gl_Position = vec4(p0 + bias , 0, 1); \n"
   "  EmitVertex(); \n"
   "  \n"
   "  vertex_out.color = vertex_in[0].color; \n"
   "  vertex_out.texCoord = vec2(0, 0); \n"
   "  gl_Position = vec4(p0 - bias, 0, 1); \n"
   "  EmitVertex(); \n"
   "  \n"
   "  vertex_out.color = vertex_in[1].color; \n"
   "  vertex_out.texCoord = vec2(0, 1); \n"
   "  gl_Position = vec4(p1 + bias, 0, 1); \n"
   "  EmitVertex(); \n"
   "  vertex_out.color = vertex_in[1].color; \n"
   "  vertex_out.texCoord = vec2(0, 0); \n"
   "  gl_Position = vec4(p1 - bias, 0, 1); \n"
   "  EmitVertex(); \n"
   "  EndPrimitive(); \n"
   "}\n"
;

char const* const gouraud_frag = 
   "#version 410\n"
   "uniform int u_numTextures;\n"
   "uniform sampler2D u_sampler_2D[1]; \n"
   "in VertexData \n"
   "{\n"
   "  vec4 color;\n"
   "  vec4 texCoord; \n"
   "} vertex_in; \n"
   "out vec4 fragData; \n"
   "void main() \n"
   "{\n"
   "  vec4 texColors = vec4(1); \n"
   "  \n"
   "  if(u_numTextures > 0)\n"
   "  {\n"
   "    texColors *= texture(u_sampler_2D[0], vertex_in.texCoord.st); \n"
   "  } \n"
   "  fragData = vertex_in.color * texColors; \n"
   "}\n"
;

char const* const phong_frag = 
   "#version 410\n"
   "uniform struct Material\n"
   "{\n"
   "  vec4 diffuse; \n"
   "  vec4 ambient; \n"
   "  vec4 specular; \n"
   "  vec4 emission; \n"
   "  float shinyness; \n"
   "};\n"
   "struct Lightsource\n"
   "{\n"
   "  vec3 position; \n"
   "  vec4 diffuse; \n"
   "  vec4 ambient; \n"
   "  vec4 specular; \n"
   "  vec3 spotDirection; \n"
   "  float spotCosCutoff; \n"
   "  float spotExponent; \n"
   "  float constantAttenuation; \n"
   "  float linearAttenuation; \n"
   "  float quadraticAttenuation; \n"
   "  int type; \n"
   "};\n"
   "vec4 shade(in Lightsource light, in Material mat, in vec3 normal, in vec3 eyeVec, in vec4 base_color)\n"
   "{\n"
   "  vec3 lightDir = light.type > 0 ? (light.position - eyeVec) : -light.position; \n"
   "  vec3 L = normalize(lightDir); \n"
   "  vec3 E = normalize(-eyeVec); \n"
   "  vec3 R = reflect(-L, normal); \n"
   "  vec4 ambient = mat.ambient * light.ambient; \n"
   "  float att = 1.0; \n"
   "  float nDotL = dot(normal, L); \n"
   "  \n"
   "  if (light.type > 0)\n"
   "  {\n"
   "    float dist = length(lightDir); \n"
   "    att = 1.0 / (light.constantAttenuation + light.linearAttenuation * dist + light.quadraticAttenuation * dist * dist); \n"
   "    \n"
   "    if(light.type > 1)\n"
   "    {\n"
   "      float spotEffect = dot(normalize(light.spotDirection), -L); \n"
   "      \n"
   "      if (spotEffect < light.spotCosCutoff)\n"
   "      {\n"
   "        att = 0.0;\n"
   "        base_color * ambient; \n"
   "      }\n"
   "      spotEffect = pow(spotEffect, light.spotExponent); \n"
   "      att *= spotEffect; \n"
   "    }\n"
   "  }\n"
   "  nDotL = max(0.0, nDotL); \n"
   "  float specIntesity = clamp(pow( max(dot(R, E), 0.0), mat.shinyness), 0.0, 1.0); \n"
   "  vec4 diffuse = att * mat.diffuse * light.diffuse * vec4(vec3(nDotL), 1.0); \n"
   "  vec4 spec = att * mat.specular * light.specular * specIntesity; \n"
   "  spec.a = 0.0; \n"
   "  return base_color * (ambient + diffuse) + spec; \n"
   "}\n"
   "uniform Material u_material;\n"
   "//layout(std140) uniform MaterialBlock\n"
   "//{\n"
   "//  Material u_material;\n"
   "//};\n"
   "//uniform Lightsource u_lights[16]; \n"
   "layout(std140) uniform LightBlock\n"
   "{\n"
   "  int u_numLights;\n"
   "  Lightsource u_lights[16];\n"
   "};\n"
   "uniform int u_numTextures; \n"
   "uniform sampler2D u_sampler_2D[4]; \n"
   "in VertexData\n"
   "{\n"
   "  vec4 color;\n"
   "  vec4 texCoord;\n"
   "  vec3 normal; \n"
   "  vec3 eyeVec; \n"
   "} vertex_in;\n"
   "out vec4 fragData; \n"
   "void main() \n"
   "{\n"
   "  vec4 texColors = vec4(1); \n"
   "  \n"
   "  for(int i = 0; i < u_numTextures; i++) \n"
   "  {\n"
   "    texColors *= texture(u_sampler_2D[i], vertex_in.texCoord.st); \n"
   "  } \n"
   "  vec3 normal = normalize(vertex_in.normal); \n"
   "  vec4 shade_color = vec4(0); \n"
   "  \n"
   "  if(u_numLights > 0) \n"
   "    shade_color += shade(u_lights[0], u_material, normal, vertex_in.eyeVec, texColors); \n"
   "  \n"
   "  if(u_numLights > 1)\n"
   "    shade_color += shade(u_lights[1], u_material, normal, vertex_in.eyeVec, texColors); \n"
   "  if(u_numLights > 2)\n"
   "    shade_color += shade(u_lights[2], u_material, normal, vertex_in.eyeVec, texColors); \n"
   "  \n"
   "  if(u_numLights > 3) shade_color += shade(u_lights[3], u_material, normal, vertex_in.eyeVec, texColors); \n"
   "  \n"
   "  fragData = shade_color; \n"
   "}\n"
;

char const* const phong_normalmap_frag = 
   "#version 330\n"
   "uniform int u_numTextures; \n"
   "uniform sampler2D u_sampler_2D[4]; \n"
   "uniform struct\n"
   "{\n"
   "  vec4 diffuse; \n"
   "  vec4 ambient; \n"
   "  vec4 specular; \n"
   "  vec4 emission; \n"
   "  float shinyness; \n"
   "} u_material; \n"
   "in VertexData\n"
   "{ \n"
   "  vec4 color; \n"
   "  vec4 texCoord; \n"
   "  vec3 normal; \n"
   "  vec3 eyeVec; \n"
   "  vec3 lightDir; \n"
   "} vertex_in; \n"
   "out vec4 fragData; \n"
   "vec3 normalFromHeightMap(sampler2D theMap, vec2 theCoords, float theStrength) \n"
   "{\n"
   "  float center = texture(theMap, theCoords).r;\n"
   "  float U = texture(theMap, theCoords + vec2( 0.005, 0)).r;\n"
   "  float V = texture(theMap, theCoords + vec2(0, 0.005)).r;\n"
   "  float dHdU = U - center; \n"
   "  float dHdV = V - center; \n"
   "  vec3 normal = vec3( -dHdU, dHdV, 0.05 / theStrength); \n"
   "  return normalize(normal);\n"
   "}\n"
   "void main()\n"
   "{\n"
   "  vec4 texColors = texture(u_sampler_2D[0], vertex_in.texCoord.xy); \n"
   "  vec3 N; \n"
   "  N = normalFromHeightMap(u_sampler_2D[1], vertex_in.texCoord.xy, 0.8); \n"
   "  vec3 L = normalize(-vertex_in.lightDir); \n"
   "  vec3 E = normalize(vertex_in.eyeVec); \n"
   "  vec3 R = reflect(-L, N); \n"
   "  float nDotL = max(0.0, dot(N, L));\n"
   "  float specIntesity = pow( max(dot(R, E), 0.0), u_material.shinyness);\n"
   "  vec4 spec = u_material.specular * specIntesity;\n"
   "  spec.a = 0.0;\n"
   "  fragData = texColors * (u_material.ambient + u_material.diffuse * vec4(vec3(nDotL), 1.0)) + spec; \n"
   "}\n"
;

char const* const points_frag = 
   "#version 330\n"
   "uniform int u_numTextures;\n"
   "uniform sampler2D u_sampler_2D[1]; \n"
   "uniform struct\n"
   "{\n"
   "  vec4 diffuse; \n"
   "  vec4 ambient; \n"
   "  vec4 specular; \n"
   "  vec4 emission; \n"
   "} u_material; \n"
   "in vec4 v_color; \n"
   "out vec4 fragData; \n"
   "void main() \n"
   "{\n"
   "  vec4 texColors = v_color; \n"
   "  \n"
   "  if(u_numTextures > 0)\n"
   "  {\n"
   "    texColors *= texture(u_sampler_2D[0], gl_PointCoord.xy); \n"
   "  } \n"
   "  fragData = u_material.diffuse * texColors; \n"
   "}\n"
;

char const* const points_sphere_frag = 
   "#version 330\n"
   "struct Material\n"
   "{\n"
   "  vec4 diffuse; \n"
   "  vec4 ambient; \n"
   "  vec4 specular; \n"
   "  vec4 emission; \n"
   "  float shinyness; \n"
   "};\n"
   "uniform int u_numLights; \n"
   "struct Lightsource\n"
   "{\n"
   "  int type; \n"
   "  vec3 position; \n"
   "  vec4 diffuse; \n"
   "  vec4 ambient; \n"
   "  vec4 specular; \n"
   "  float constantAttenuation; \n"
   "  float linearAttenuation; \n"
   "  float quadraticAttenuation; \n"
   "  vec3 spotDirection; \n"
   "  float spotCosCutoff; \n"
   "  float spotExponent; \n"
   "};\n"
   "vec4 shade(in Lightsource light, in Material mat, in vec3 normal, in vec3 eyeVec, in vec4 base_color)\n"
   "{\n"
   "  vec3 lightDir = light.type > 0 ? (light.position - eyeVec) : -light.position; \n"
   "  vec3 L = normalize(lightDir); \n"
   "  vec3 E = normalize(-eyeVec); \n"
   "  vec3 R = reflect(-L, normal); \n"
   "  vec4 ambient = mat.ambient * light.ambient; \n"
   "  float att = 1.0; \n"
   "  float nDotL = dot(normal, L); \n"
   "  if (light.type > 0)\n"
   "  {\n"
   "    float dist = length(lightDir); \n"
   "    att = 1.0 / (light.constantAttenuation + light.linearAttenuation * dist + light.quadraticAttenuation * dist * dist); \n"
   "    \n"
   "    if(light.type > 1) \n"
   "    {\n"
   "      float spotEffect = dot(normalize(light.spotDirection), -L); \n"
   "      \n"
   "      if (spotEffect < light.spotCosCutoff) \n"
   "      {\n"
   "        att = 0.0; \n"
   "        base_color * ambient; \n"
   "      } \n"
   "      spotEffect = pow(spotEffect, light.spotExponent); \n"
   "      att *= spotEffect; \n"
   "    }\n"
   "  }\n"
   "  nDotL = max(0.0, nDotL); \n"
   "  float specIntesity = clamp(pow( max(dot(R, E), 0.0), mat.shinyness), 0.0, 1.0); \n"
   "  vec4 diffuse = att * mat.diffuse * light.diffuse * vec4(vec3(nDotL), 1.0); \n"
   "  vec4 spec = att * mat.specular * light.specular * specIntesity; \n"
   "  spec.a = 0.0; \n"
   "  return base_color * (ambient + diffuse) + spec; \n"
   "}\n"
   "uniform float u_pointRadius; \n"
   "uniform vec3 u_lightDir; \n"
   "uniform int u_numTextures; \n"
   "uniform sampler2D u_sampler_2D[8]; \n"
   "uniform Lightsource u_lights[16]; \n"
   "uniform Material u_material; \n"
   "in vec4 v_color; \n"
   "in vec3 v_eyeVec; \n"
   "out vec4 fragData; \n"
   "void main() \n"
   "{\n"
   "  vec4 texColors = v_color; \n"
   "  \n"
   "  for(int i = 0; i < u_numTextures; i++) \n"
   "  { \n"
   "    texColors *= texture(u_sampler_2D[i], gl_PointCoord); \n"
   "  }\n"
   "  vec3 N; \n"
   "  N.xy = gl_PointCoord * vec2(2.0, -2.0) + vec2(-1.0, 1.0); \n"
   "  float mag = dot(N.xy, N.xy); \n"
   "  \n"
   "  if (mag > 1.0) discard; \n"
   "  \n"
   "  N.z = sqrt(1.0 - mag); \n"
   "  vec3 spherePosEye = v_eyeVec + N * u_pointRadius; \n"
   "  vec3 L = normalize(-u_lightDir); \n"
   "  vec3 E = normalize(v_eyeVec); \n"
   "  float nDotL = max(0.0, dot(N, L)); \n"
   "  vec3 v = normalize(-spherePosEye); \n"
   "  vec3 h = normalize(-u_lightDir + v); \n"
   "  float specIntesity = pow( max(dot(N, h), 0.0), u_material.shinyness); \n"
   "  vec4 spec = u_material.specular * specIntesity; \n"
   "  spec.a = 0.0; \n"
   "  fragData = texColors * (u_material.ambient + u_material.diffuse * vec4(vec3(nDotL), 1.0)) + spec; \n"
   "}\n"
;

char const* const unlit_frag = 
   "#version 410\n"
   "uniform int u_numTextures;\n"
   "uniform sampler2D u_sampler_2D[1];\n"
   "uniform struct Material \n"
   "{\n"
   "  vec4 diffuse;\n"
   "  vec4 ambient;\n"
   "  vec4 specular; \n"
   "  vec4 emission; \n"
   "  float shinyness; \n"
   "} u_material;\n"
   "in VertexData\n"
   "{\n"
   "  vec4 color; \n"
   "  vec2 texCoord;\n"
   "} vertex_in; \n"
   "out vec4 fragData;\n"
   "void main() \n"
   "{\n"
   "  vec4 texColors = vertex_in.color;\n"
   "  if(u_numTextures > 0) \n"
   "    texColors *= texture(u_sampler_2D[0], vertex_in.texCoord.st); \n"
   "  fragData = u_material.diffuse * texColors; \n"
   "}\n"
;

char const* const unlit_rect_frag = 
   "#version 410\n"
   "uniform int u_numTextures;\n"
   "uniform sampler2DRect u_sampler_2Drect[1];\n"
   "uniform struct Material \n"
   "{\n"
   "  vec4 diffuse;\n"
   "  vec4 ambient;\n"
   "  vec4 specular; \n"
   "  vec4 emission; \n"
   "  float shinyness; \n"
   "} u_material;\n"
   "in VertexData\n"
   "{\n"
   "  vec4 color; \n"
   "  vec2 texCoord;\n"
   "} vertex_in; \n"
   "out vec4 fragData;\n"
   "void main() \n"
   "{\n"
   "  vec4 texColors = vertex_in.color;\n"
   "  if(u_numTextures > 0) \n"
   "    texColors *= texture(u_sampler_2Drect[0], vertex_in.texCoord.st); \n"
   "  fragData = u_material.diffuse * texColors; \n"
   "}\n"
;
