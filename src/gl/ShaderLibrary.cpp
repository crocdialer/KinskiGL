/* Generated file, do not edit! */

#include "ShaderLibrary.h"


char const* const points_vert = 
   "uniform mat4 u_modelViewProjectionMatrix;\n"
   "uniform float u_pointSize;\n"
   "attribute vec4 a_vertex;\n"
   "attribute vec4 a_color;\n"
   "attribute float a_pointSize;\n"
   "varying lowp vec4 v_color;\n"
   "void main()\n"
   "{\n"
   "  gl_Position = u_modelViewProjectionMatrix * a_vertex;\n"
   "  gl_PointSize = a_pointSize;\n"
   "  v_color = a_color;\n"
   "}\n"
;

char const* const gouraud_vert = 
   "struct Material\n"
   "{\n"
   "  vec4 diffuse; \n"
   "  vec4 ambient; \n"
   "  vec4 specular; \n"
   "  vec4 emission; \n"
   "  vec4 point_vals;// (size, constant_att, linear_att, quad_att) \n"
   "  float shinyness;\n"
   "};\n"
   "uniform int u_numLights;\n"
   "struct Lightsource \n"
   "{\n"
   "  int type;\n"
   "  vec3 position;\n"
   "  vec4 diffuse; \n"
   "  vec4 ambient; \n"
   "  vec4 specular; \n"
   "  float constantAttenuation; \n"
   "  float linearAttenuation; \n"
   "  float quadraticAttenuation; \n"
   "  vec3 spotDirection; \n"
   "  float spotCosCutoff; \n"
   "  float spotExponent; \n"
   "};\n"
   "vec4 shade(in Lightsource light, in Material mat, in vec3 normal, in vec3 eyeVec, in vec4 base_color) \n"
   "{\n"
   "  vec3 lightDir = light.type > 0 ? (light.position - eyeVec) : -light.position;\n"
   "  vec3 L = normalize(lightDir); \n"
   "  vec3 E = normalize(-eyeVec); \n"
   "  vec3 R = reflect(-L, normal); \n"
   "  vec4 ambient = mat.ambient * light.ambient; \n"
   "  float att = 1.0; \n"
   "  float nDotL = dot(normal, L); \n"
   "  \n"
   "  if (light.type > 0) \n"
   "  {\n"
   "    float dist = length(lightDir); \n"
   "    att = 1.0 / (light.constantAttenuation + light.linearAttenuation * dist + light.quadraticAttenuation * dist * dist); \n"
   "    if(light.type > 1) \n"
   "    {\n"
   "      float spotEffect = dot(normalize(light.spotDirection), -L); \n"
   "      if (spotEffect < light.spotCosCutoff) \n"
   "      {\n"
   "        att = 0.0;\n"
   "        base_color * ambient; \n"
   "      }\n"
   "      spotEffect = pow(spotEffect, light.spotExponent); \n"
   "      att *= spotEffect; \n"
   "    }\n"
   "  } \n"
   "  nDotL = max(0.0, nDotL); \n"
   "  float specIntesity = clamp(pow( max(dot(R, E), 0.0), mat.shinyness), 0.0, 1.0); \n"
   "  vec4 diffuse = att * mat.diffuse * light.diffuse * vec4(vec3(nDotL), 1.0); \n"
   "  vec4 spec = att * mat.specular * light.specular * specIntesity; spec.a = 0.0; \n"
   "  return base_color * (ambient + diffuse) + spec; \n"
   "}\n"
   "uniform mat4 u_modelViewMatrix; \n"
   "uniform mat4 u_modelViewProjectionMatrix; \n"
   "uniform mat3 u_normalMatrix; \n"
   "uniform mat4 u_textureMatrix; \n"
   "uniform Material u_material; \n"
   "uniform Lightsource u_lights[2]; \n"
   "attribute vec4 a_vertex; \n"
   "attribute vec3 a_normal; \n"
   "attribute vec4 a_texCoord; \n"
   "varying vec4 v_color;\n"
   "varying vec4 v_texCoord; \n"
   "void main() \n"
   "{\n"
   "  v_texCoord = u_textureMatrix * a_texCoord;\n"
   "  vec3 normal = normalize(u_normalMatrix * a_normal); \n"
   "  vec3 eyeVec = (u_modelViewMatrix * a_vertex).xyz;\n"
   "  vec4 shade_color = vec4(0);\n"
   "  if(u_numLights > 0)\n"
   "    shade_color += shade(u_lights[0], u_material, normal, eyeVec, vec4(1)); \n"
   "  \n"
   "  if(u_numLights > 1)\n"
   "    shade_color += shade(u_lights[1], u_material, normal, eyeVec, vec4(1));\n"
   "  \n"
   "  v_color = shade_color; \n"
   "  gl_Position = u_modelViewProjectionMatrix * a_vertex; \n"
   "}\n"
;

char const* const phong_vert = 
   "uniform mat4 u_modelViewMatrix;\n"
   "uniform mat4 u_modelViewProjectionMatrix;\n"
   "uniform mat3 u_normalMatrix;\n"
   "uniform mat4 u_textureMatrix;\n"
   "attribute vec4 a_vertex;\n"
   "attribute vec4 a_texCoord;\n"
   "attribute vec3 a_normal;\n"
   "varying lowp vec4 v_texCoord;\n"
   "varying mediump vec3 v_normal;\n"
   "varying mediump vec3 v_eyeVec;\n"
   "void main()\n"
   "{\n"
   "  v_normal = normalize(u_normalMatrix * a_normal);\n"
   "  v_texCoord =  u_textureMatrix * a_texCoord;\n"
   "  v_eyeVec = - (u_modelViewMatrix * a_vertex).xyz;\n"
   "  gl_Position = u_modelViewProjectionMatrix * a_vertex;\n"
   "}\n"
;

char const* const phong_skin_vert = 
   "uniform mat4 u_modelViewMatrix;\n"
   "uniform mat4 u_modelViewProjectionMatrix;\n"
   "uniform mat3 u_normalMatrix;\n"
   "uniform mat4 u_textureMatrix;\n"
   "uniform mat4 u_bones[18];\n"
   "attribute vec4 a_vertex;\n"
   "attribute vec4 a_texCoord;\n"
   "attribute vec3 a_normal;\n"
   "attribute vec4 a_boneIds;\n"
   "attribute vec4 a_boneWeights;\n"
   "varying vec4 v_texCoord;\n"
   "varying vec3 v_normal;\n"
   "varying vec3 v_eyeVec;\n"
   "void main()\n"
   "{\n"
   "  vec4 newVertex = vec4(0.0);\n"
   "  vec4 newNormal = vec4(0.0);\n"
   "  \n"
   "  for (int i = 0; i < 4; i++)\n"
   "  {\n"
   "    newVertex += u_bones[int(floor(a_boneIds[i]))] * a_vertex * a_boneWeights[i];\n"
   "    newNormal += u_bones[int(floor(a_boneIds[i]))] * vec4(a_normal, 0.0) * a_boneWeights[i];\n"
   "  }\n"
   "  v_normal = normalize(u_normalMatrix * newNormal.xyz);\n"
   "  v_texCoord =  u_textureMatrix * a_texCoord;\n"
   "  v_eyeVec = - (u_modelViewMatrix * newVertex).xyz;\n"
   "  gl_Position = u_modelViewProjectionMatrix * vec4(newVertex.xyz, 1.0);\n"
   "}\n"
;

char const* const unlit_skin_vert = 
   "uniform mat4 u_modelViewProjectionMatrix;\n"
   "uniform mat4 u_textureMatrix;\n"
   "uniform mat4 u_bones[64];\n"
   "attribute vec4 a_vertex;\n"
   "attribute vec4 a_texCoord;\n"
   "attribute vec4 a_color;\n"
   "attribute vec4 a_boneIds; \n"
   "attribute vec4 a_boneWeights;\n"
   "varying lowp vec4 v_color;\n"
   "varying lowp vec4 v_texCoord;\n"
   "void main(void)\n"
   "{\n"
   "  v_color = a_color;\n"
   "  v_texCoord =  u_textureMatrix * a_texCoord;\n"
   "  \n"
   "  vec4 newVertex = vec4(0); \n"
   "  \n"
   "  for (int i = 0; i < 4; i++)\n"
   "  {\n"
   "    newVertex += u_bones[int(a_boneIds[i])] * a_vertex * a_boneWeights[i]; \n"
   "  }\n"
   "  gl_Position = u_modelViewProjectionMatrix * vec4(newVertex.xyz, 1.0);\n"
   "}\n"
;

char const* const quad_warp_vert = 
   "#version 330\n"
   "uniform mat4 u_modelViewProjectionMatrix;\n"
   "uniform mat4 u_textureMatrix;\n"
   "// {TL, BL, BR, TR}\n"
   "// {TL, TR, BL, BR}\n"
   "uniform vec2[4] u_control_points;\n"
   "attribute vec4 a_vertex;\n"
   "attribute vec4 a_texCoord;\n"
   "attribute vec4 a_color;\n"
   "varying lowp vec4 v_color;\n"
   "varying lowp vec4 v_texCoord;\n"
   "void main() \n"
   "{\n"
   "  // interpolate bottom edge x coordinate\n"
   "  vec2 x1 = mix(u_control_points[2], u_control_points[3], a_vertex.x);\n"
   "  // interpolate top edge x coordinate\n"
   "  vec2 x2 = mix(u_control_points[0], u_control_points[1], a_vertex.x);\n"
   "  // interpolate y position\n"
   "  vec2 p = mix(x1, x2, a_vertex.y);\n"
   "  v_color = a_color;\n"
   "  v_texCoord =  u_textureMatrix * a_texCoord;\n"
   "  gl_Position = u_modelViewProjectionMatrix * vec4(p, 0, 1); \n"
   "}\n"
;

char const* const unlit_vert = 
   "uniform mat4 u_modelViewProjectionMatrix;\n"
   "uniform mat4 u_textureMatrix;\n"
   "attribute vec4 a_vertex;\n"
   "attribute vec4 a_texCoord;\n"
   "attribute vec4 a_color;\n"
   "varying lowp vec4 v_color;\n"
   "varying lowp vec4 v_texCoord;\n"
   "void main(void)\n"
   "{\n"
   "  v_color = a_color;\n"
   "  v_texCoord =  u_textureMatrix * a_texCoord;\n"
   "  gl_Position = u_modelViewProjectionMatrix * a_vertex;\n"
   "}\n"
;

char const* const unlit_frag = 
   "precision mediump float;\n"
   "precision lowp int;\n"
   "uniform int u_numTextures;\n"
   "uniform sampler2D u_textureMap[1];\n"
   "struct Material\n"
   "{\n"
   "  vec4 diffuse; \n"
   "  vec4 ambient; \n"
   "  vec4 specular; \n"
   "  vec4 emission; \n"
   "  vec4 point_vals;// (size, constant_att, linear_att, quad_att) \n"
   "  float shinyness;\n"
   "}; \n"
   "uniform Material u_material;\n"
   "varying vec4 v_color;\n"
   "varying vec4 v_texCoord;\n"
   "void main(void)\n"
   "{\n"
   "  vec4 texColors = v_color;\n"
   "  if(u_numTextures > 0)\n"
   "    texColors *= texture2D(u_textureMap[0], v_texCoord.st);\n"
   "  gl_FragColor = u_material.diffuse * texColors;\n"
   "}\n"
;

char const* const phong_frag = 
   "precision mediump float;\n"
   "precision lowp int;\n"
   "uniform int u_numTextures;\n"
   "uniform sampler2D u_sampler_2D[2];\n"
   "uniform vec3 u_lightDir;\n"
   "struct Material\n"
   "{\n"
   "  vec4 diffuse; \n"
   "  vec4 ambient; \n"
   "  vec4 specular; \n"
   "  vec4 emission; \n"
   "  vec4 point_vals;// (size, constant_att, linear_att, quad_att) \n"
   "  float shinyness;\n"
   "}; \n"
   "uniform Material u_material;\n"
   "varying vec3 v_normal;\n"
   "varying vec4 v_texCoord;\n"
   "varying vec3 v_eyeVec;\n"
   "void main()\n"
   "{\n"
   "  vec4 texColors = vec4(1);\n"
   "  if(u_numTextures > 0) texColors *= texture2D(u_sampler_2D[0], v_texCoord.st);\n"
   "  if(u_numTextures > 1) texColors *= texture2D(u_sampler_2D[1], v_texCoord.st);\n"
   "  \n"
   "  vec3 N = normalize(v_normal);\n"
   "  vec3 L = normalize(-u_lightDir);\n"
   "  vec3 E = normalize(v_eyeVec);\n"
   "  vec3 R = reflect(-L, N);\n"
   "    \n"
   "  float nDotL = max(0.0, dot(N, L));\n"
   "  float specIntesity = pow( max(dot(R, E), 0.0), u_material.shinyness);\n"
   "  vec4 spec = u_material.specular * specIntesity; spec.a = 0.0;\n"
   "  gl_FragColor = texColors * (u_material.ambient + u_material.diffuse * vec4(vec3(nDotL), 1.0)) + spec;\n"
   "}\n"
;

char const* const points_frag = 
   "uniform int u_numTextures;\n"
   "uniform sampler2D u_sampler_2D[1];\n"
   "uniform struct\n"
   "{\n"
   "  vec4 diffuse;\n"
   "  vec4 ambient;\n"
   "  vec4 specular;\n"
   "  vec4 emission;\n"
   "  float shinyness;\n"
   "} u_material;\n"
   "varying vec4 v_color;\n"
   "void main()\n"
   "{\n"
   "  vec4 texColors = v_color;\n"
   "  if(u_numTextures > 0)\n"
   "  {\n"
   "    texColors *= texture2D(u_textureMap[i], gl_PointCoord);\n"
   "  }\n"
   "  gl_FragColor = u_material.diffuse * texColors;\n"
   "}\n"
;

char const* const gouraud_frag = 
   "uniform int u_numTextures;\n"
   "uniform sampler2D u_sampler_2D[1]; \n"
   "varying vec4 v_color;\n"
   "varying vec4 v_texCoord; \n"
   "void main() \n"
   "{\n"
   "  vec4 texColors = vec4(1); \n"
   "  texColors *= texture2D(u_sampler_2D[0], v_texCoord.st); \n"
   "  gl_FragColor = v_color * texColors; \n"
   "}\n"
;

char const* const noise_3D_frag = 
   "//\n"
   "// Description : Array and textureless GLSL 2D/3D/4D simplex \n"
   "//               noise functions.\n"
   "//      Author : Ian McEwan, Ashima Arts.\n"
   "//  Maintainer : ijm\n"
   "//     Lastmod : 20110822 (ijm)\n"
   "//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n"
   "//               Distributed under the MIT License. See LICENSE file.\n"
   "//               https://github.com/ashima/webgl-noise\n"
   "// \n"
   "uniform vec2 u_scale = vec2(1.0);\n"
   "uniform float u_seed = 0.0;\n"
   "vec3 mod289(vec3 x) \n"
   "{\n"
   "  return x - floor(x * (1.0 / 289.0)) * 289.0;\n"
   "}\n"
   "vec4 mod289(vec4 x) \n"
   "{\n"
   "  return x - floor(x * (1.0 / 289.0)) * 289.0;\n"
   "}\n"
   "vec4 permute(vec4 x) \n"
   "{\n"
   "  return mod289(((x*34.0)+1.0)*x);\n"
   "}\n"
   "vec4 taylorvSqrt(vec4 r)\n"
   "{\n"
   "  return 1.79284291400159 - 0.85373472095314 * r;\n"
   "}\n"
   "float snoise(vec3 v)\n"
   "{ \n"
   "  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n"
   "  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n"
   "// First corner\n"
   "  vec3 i  = floor(v + dot(v, C.yyy) );\n"
   "  vec3 x0 =   v - i + dot(i, C.xxx) ;\n"
   "// Other corners\n"
   "  vec3 g = step(x0.yzx, x0.xyz);\n"
   "  vec3 l = 1.0 - g;\n"
   "  vec3 i1 = min( g.xyz, l.zxy );\n"
   "  vec3 i2 = max( g.xyz, l.zxy );\n"
   "  vec3 x1 = x0 - i1 + C.xxx;\n"
   "  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n"
   "  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n"
   "  // Permutations\n"
   "  i = mod289(i); \n"
   "  vec4 p = permute( permute( permute( \n"
   "             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n"
   "           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n"
   "           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n"
   "  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n"
   "  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n"
   "  float n_ = 0.142857142857; // 1.0/7.0\n"
   "  vec3  ns = n_ * D.wyz - D.xzx;\n"
   "  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n"
   "  vec4 x_ = floor(j * ns.z);\n"
   "  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n"
   "  vec4 x = x_ *ns.x + ns.yyyy;\n"
   "  vec4 y = y_ *ns.x + ns.yyyy;\n"
   "  vec4 h = 1.0 - abs(x) - abs(y);\n"
   "  vec4 b0 = vec4( x.xy, y.xy );\n"
   "  vec4 b1 = vec4( x.zw, y.zw );\n"
   "  vec4 s0 = floor(b0)*2.0 + 1.0;\n"
   "  vec4 s1 = floor(b1)*2.0 + 1.0;\n"
   "  vec4 sh = -step(h, vec4(0.0));\n"
   "  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n"
   "  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n"
   "  vec3 p0 = vec3(a0.xy,h.x);\n"
   "  vec3 p1 = vec3(a0.zw,h.y);\n"
   "  vec3 p2 = vec3(a1.xy,h.z);\n"
   "  vec3 p3 = vec3(a1.zw,h.w);\n"
   "//Normalise gradients\n"
   "  vec4 norm = taylorvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n"
   "  p0 *= norm.x;\n"
   "  p1 *= norm.y;\n"
   "  p2 *= norm.z;\n"
   "  p3 *= norm.w;\n"
   "// Mix final noise value\n"
   "  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n"
   "  m = m * m;\n"
   "  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n"
   "                                dot(p2,x2), dot(p3,x3) ) );\n"
   "}\n"
   "void main() \n"
   "{\n"
   "  float noise_val = (snoise(vec3(gl_FragCoord.xy * u_scale, u_seed)) + 1) / 2.0; \n"
   "  gl_FragColor = vec4(vec3(noise_val), 1.0); \n"
   "}\n"
;
